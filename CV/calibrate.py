import os
import time
import glob
import numpy as np
import cv2 as cv


#CHATGPT WROTE THIS FROM THE SAMPLE SCRIPT IN THE OPENCV DOCS HERE: https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html
# -----------------------------
# Settings (edit these)
# -----------------------------
CAM_INDEX = 0

# Inner corners (must match your printed board)
PATTERN_SIZE = (9, 6)  # (cols, rows) inner corners

# Physical square size (optional for intrinsics; useful for correct scaling)
# Use meters if you care about tvec units later. Example: 25mm squares => 0.025
SQUARE_SIZE = 0.025

CAPTURE_DIR = "calib_images"
OUTPUT_FILE = "cam_constants.py"

# How many good frames to capture before calibrating (you can calibrate early too)
TARGET_CAPTURES = 20

# Termination criteria for corner refinement
criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 1e-3)

# -----------------------------
# Helpers
# -----------------------------
def make_object_points(pattern_size, square_size):
    cols, rows = pattern_size
    objp = np.zeros((rows * cols, 3), np.float32)
    objp[:, :2] = np.mgrid[0:cols, 0:rows].T.reshape(-1, 2)
    objp *= float(square_size)
    return objp

def find_corners(gray, pattern_size):
    # Good defaults for chessboard detection
    flags = cv.CALIB_CB_ADAPTIVE_THRESH | cv.CALIB_CB_NORMALIZE_IMAGE
    ret, corners = cv.findChessboardCorners(gray, pattern_size, flags)
    if not ret:
        return False, None

    corners2 = cv.cornerSubPix(
        gray, corners, (11, 11), (-1, -1), criteria
    )
    return True, corners2

def calibrate_from_images(image_paths, pattern_size, square_size):
    objp = make_object_points(pattern_size, square_size)

    objpoints = []
    imgpoints = []
    img_size = None
    used = 0

    for path in image_paths:
        img = cv.imread(path)
        if img is None:
            continue
        gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        img_size = (gray.shape[1], gray.shape[0])  # (w, h)

        ok, corners = find_corners(gray, pattern_size)
        if ok:
            objpoints.append(objp)
            imgpoints.append(corners)
            used += 1

    if used < 5:
        raise RuntimeError(f"Not enough valid calibration images. Found corners in only {used} images.")

    # Calibrate
    ret, mtx, dist, rvecs, tvecs = cv.calibrateCamera(
        objpoints, imgpoints, img_size, None, None
    )

    # Compute mean reprojection error (sanity check)
    mean_error = 0.0
    total_points = 0

    for i in range(len(objpoints)):
        imgpoints2, _ = cv.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
        err = cv.norm(imgpoints[i], imgpoints2, cv.NORM_L2)
        mean_error += err
        total_points += len(imgpoints2)

    mean_error = mean_error / total_points

    return mtx, dist, mean_error, used

def write_cam_constants(path, intrinsic, dist):
    intrinsic = np.array(intrinsic, dtype=float)
    dist = np.array(dist, dtype=float).reshape(-1)

    content = f"""# Auto-generated by calibration script
# Generated: {time.strftime("%Y-%m-%d %H:%M:%S")}

import numpy as np

INTRINSIC_MAT = np.array(
{np.array2string(intrinsic, separator=', ', precision=10)},
dtype=float
)

# OpenCV distortion coefficients:
# Typically [k1, k2, p1, p2, k3] (and sometimes more depending on model)
DISTORTION_COEFFS = np.array(
{np.array2string(dist, separator=', ', precision=10)},
dtype=float
)
"""
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

# -----------------------------
# Main: capture + calibrate
# -----------------------------
def main():
    os.makedirs(CAPTURE_DIR, exist_ok=True)

    cap = cv.VideoCapture(CAM_INDEX)
    if not cap.isOpened():
        raise RuntimeError(
            f"Could not open camera index {CAM_INDEX}. "
            "If you're on WSL with a built-in webcam, run this in Windows Python."
        )

    print("Webcam calibration capture")
    print("-------------------------")
    print("Controls:")
    print("  SPACE  - capture image (only saves if chessboard is detected)")
    print("  c      - calibrate using saved images now")
    print("  r      - reset/delete captured images")
    print("  q / ESC- quit")
    print()

    captured = 0

    while True:
        ok, frame = cap.read()
        if not ok:
            print("Failed to read frame.")
            break

        display = frame.copy()
        gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
        found, corners = find_corners(gray, PATTERN_SIZE)

        if found:
            cv.drawChessboardCorners(display, PATTERN_SIZE, corners, found)
            cv.putText(display, "Chessboard: FOUND", (20, 40), cv.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        else:
            cv.putText(display, "Chessboard: NOT FOUND", (20, 40), cv.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        cv.putText(display, f"Captured: {captured}  (target {TARGET_CAPTURES})", (20, 80),
                   cv.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 255), 2)

        cv.imshow("Calibration Capture", display)

        key = cv.waitKey(1) & 0xFF

        if key in (27, ord('q')):  # ESC or q
            break

        if key == ord('r'):
            # delete captured images
            for p in glob.glob(os.path.join(CAPTURE_DIR, "*.jpg")):
                try:
                    os.remove(p)
                except OSError:
                    pass
            captured = 0
            print("Reset: deleted captured images.")

        if key == ord('c'):
            # calibrate now
            paths = sorted(glob.glob(os.path.join(CAPTURE_DIR, "*.jpg")))
            if not paths:
                print("No images saved yet.")
                continue
            print(f"Calibrating from {len(paths)} saved images...")
            try:
                mtx, dist, reproj, used = calibrate_from_images(paths, PATTERN_SIZE, SQUARE_SIZE)
            except Exception as e:
                print("Calibration failed:", e)
                continue

            print(f"Used {used} images with detected corners.")
            print("Intrinsic matrix (K):\n", mtx)
            print("Distortion coeffs:\n", dist.reshape(-1))
            print(f"Mean reprojection error (px): {reproj:.6f}")

            write_cam_constants(OUTPUT_FILE, mtx, dist)
            print(f"Wrote {OUTPUT_FILE}")
            print("Done. You can keep capturing more images to improve calibration.")

        if key == 32:  # SPACE
            if not found:
                print("Not saving: chessboard not detected.")
                continue

            ts = time.strftime("%Y%m%d_%H%M%S")
            out_path = os.path.join(CAPTURE_DIR, f"calib_{ts}_{captured:03d}.jpg")
            cv.imwrite(out_path, frame)
            captured += 1
            print(f"Saved {out_path}")

            # auto-calibrate when target reached
            if captured >= TARGET_CAPTURES:
                paths = sorted(glob.glob(os.path.join(CAPTURE_DIR, "*.jpg")))
                print(f"Target reached. Calibrating from {len(paths)} saved images...")
                mtx, dist, reproj, used = calibrate_from_images(paths, PATTERN_SIZE, SQUARE_SIZE)
                print(f"Used {used} images with detected corners.")
                print("Intrinsic matrix (K):\n", mtx)
                print("Distortion coeffs:\n", dist.reshape(-1))
                print(f"Mean reprojection error (px): {reproj:.6f}")
                write_cam_constants(OUTPUT_FILE, mtx, dist)
                print(f"Wrote {OUTPUT_FILE}")
                print("Keep going if you want even better calibration.")

    cap.release()
    cv.destroyAllWindows()

if __name__ == "__main__":
    main()